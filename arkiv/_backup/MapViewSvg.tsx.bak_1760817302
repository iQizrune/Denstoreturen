import * as React from "react";
import { useMemo, useRef, useState, useCallback } from "react";
import {
  View, Text, StyleSheet, LayoutChangeEvent,
  PanResponder, GestureResponderEvent, PanResponderGestureState, NativeTouchEvent
} from "react-native";
import Svg, { G, Path, Circle } from "react-native-svg";
import type { RouteLeg } from "@/src/types/route";
import { legsBoundsProjected, fitBoundsProjected, projectPoint } from "@/src/map/projection";

export type MapViewSvgProps = {
  legs: RouteLeg[];
  initialActive?: number;
  currentLeg?: number;        // ← NY: hvilken etappe vi er i nå
  focusPad?: number;          // ← NY: padding når vi fokuserer en etappe (0..1, default 0.15)
  onLegPress?: (index:number)=>void;
};

type VP = { width:number; height:number; pad?:number };

function dpSimplify(points: readonly [number,number][], tol: number): [number,number][] {
  if (points.length <= 2) return points.slice() as [number,number][];
  const sqTol = tol*tol;
  const keep = new Array(points.length).fill(false);
  keep[0] = keep[points.length-1] = true;

  const stack: [number, number][] = [[0, points.length-1]];
  function sqSegDist(p:[number,number], a:[number,number], b:[number,number]){
    let x=a[0], y=a[1], dx=b[0]-x, dy=b[1]-y;
    if (dx!==0 || dy!==0){
      let t=((p[0]-x)*dx + (p[1]-y)*dy)/(dx*dx+dy*dy);
      t=Math.max(0, Math.min(1, t));
      x = x + t*dx; y = y + t*dy;
    }
    const ux=p[0]-x, uy=p[1]-y; return ux*ux+uy*uy;
  }
  while (stack.length){
    const [first,last] = stack.pop()!;
    let idx = -1, maxSq = 0;
    const A = points[first], B = points[last];
    for (let i=first+1;i<last;i++){
      const sq = sqSegDist(points[i] as [number,number], A as [number,number], B as [number,number]);
      if (sq > maxSq){ idx=i; maxSq=sq; }
    }
    if (maxSq > sqTol && idx !== -1){
      keep[idx] = true;
      stack.push([first, idx], [idx, last]);
    }
  }
  const out: [number,number][] = [];
  for (let i=0;i<points.length;i++) if (keep[i]) out.push(points[i] as [number,number]);
  return out;
}

export default function MapViewSvg({
  legs,
  initialActive = -1,
  currentLeg,
  focusPad = 0.15,
  onLegPress,
}: MapViewSvgProps) {
  const [vp, setVp] = useState<VP>({ width: 0, height: 0, pad: 0.04 });
  const [active, setActive] = useState(initialActive);

  // Base fit + sentrering (Mercator)
  const bounds = useMemo(()=> legsBoundsProjected(legs), [legs]);
  const base   = useMemo(()=> fitBoundsProjected(bounds, vp), [bounds, vp]);
  const mx = (vp.width  - (bounds.maxX - bounds.minX) * base.scale * (1 + (vp.pad ?? 0) * 2)) / 2;
  const my = (vp.height - (bounds.maxY - bounds.minY) * base.scale * (1 + (vp.pad ?? 0) * 2)) / 2;

  const onLayout = useCallback((e:LayoutChangeEvent)=>{
    const { width, height } = e.nativeEvent.layout;
    if (width>0 && height>0) setVp(v => (v.width===width && v.height===height) ? v : ({...v, width, height}));
  },[]);

  // Pre-projiser alle legs → pikselkoordinater
  const projectedLegs = useMemo(()=>{
    if (vp.width===0 || vp.height===0) return [] as [number,number][][];
    return legs.map(leg =>
      leg.path.map(([lat,lng]) => {
        let [x,y] = projectPoint(lat, lng, vp, base.scale, base.offX, base.offY);
        return [x+mx, y+my] as [number,number];
      })
    );
  }, [legs, vp, base, mx, my]);

  // Forenkle i pikselrom (tol ~1.5 px)
  const simplifiedLegs = useMemo(()=>{
    const tol = 1.5;
    return projectedLegs.map(points => dpSimplify(points, tol));
  }, [projectedLegs]);

  // Én synlig path (rød) for alt + blå overlay for aktiv
  const visiblePath = useMemo(()=>{
    const parts: string[] = [];
    for (const leg of simplifiedLegs) {
      if (leg.length === 0) continue;
      parts.push(`M${leg[0][0]},${leg[0][1]}`);
      for (let i=1;i<leg.length;i++) parts.push(`L${leg[i][0]},${leg[i][1]}`);
    }
    return parts.join(" ");
  }, [simplifiedLegs]);

  const activePath = useMemo(()=>{
    if (active < 0 || active >= simplifiedLegs.length) return "";
    const leg = simplifiedLegs[active];
    if (leg.length === 0) return "";
    const parts = [`M${leg[0][0]},${leg[0][1]}`];
    for (let i=1;i<leg.length;i++) parts.push(`L${leg[i][0]},${leg[i][1]}`);
    return parts.join(" ");
  }, [simplifiedLegs, active]);

  // Hit-paths (for trykk)
  const hitPaths = useMemo(()=>{
    return simplifiedLegs.map(leg => {
      if (leg.length === 0) return "";
      const parts = [`M${leg[0][0]},${leg[0][1]}`];
      for (let i=1;i<leg.length;i++) parts.push(`L${leg[i][0]},${leg[i][1]}`);
      return parts.join(" ");
    });
  }, [simplifiedLegs]);

  // START/SLUTT markører for alle legs (skalerer med kartet – OK)
  const legEndpoints = useMemo(()=>{
    return simplifiedLegs.map(pts => ({
      start: pts[0],
      end:   pts[pts.length-1],
    }));
  }, [simplifiedLegs]);

  // === Transform via setNativeProps (smooth) ===
  const gRef = useRef<any>(null);
  const pending = useRef({ zoom: 1, tx: 0, ty: 0 });
  const rafId   = useRef<number | null>(null);
  const applyTransform = () => {
    const { tx, ty, zoom } = pending.current;
    if (gRef.current) {
      gRef.current.setNativeProps({
        transform: [{ translateX: tx }, { translateY: ty }, { scale: zoom }],
      } as any);
    }
  };
  const schedule = () => {
    if (rafId.current != null) return;
    rafId.current = requestAnimationFrame(() => {
      rafId.current = null;
      applyTransform();
    });
  };
  const clampZoom = (z:number)=> Math.max(0.5, Math.min(10, z));

  // Pan (én finger)
  const panRef = useRef({ startTx:0, startTy:0, lastTap:0 });
  const panResponder = React.useRef(
    PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder:  () => true,
      onPanResponderGrant: () => {
        const now = Date.now();
        if (now - panRef.current.lastTap < 250) {
          pending.current = { zoom: 1, tx: 0, ty: 0 };
          schedule();
          panRef.current.lastTap = 0;
          return;
        }
        panRef.current.lastTap = now;
        panRef.current.startTx = pending.current.tx;
        panRef.current.startTy = pending.current.ty;
      },
      onPanResponderMove: (_e, g: PanResponderGestureState) => {
        pending.current.tx = panRef.current.startTx + g.dx;
        pending.current.ty = panRef.current.startTy + g.dy;
        schedule();
      },
      onPanResponderRelease: () => {},
      onPanResponderTerminate: () => {},
    })
  ).current;

  // Pinch (to fingre)
  function dist2(a: NativeTouchEvent, b: NativeTouchEvent){ const dx=a.pageX-b.pageX, dy=a.pageY-b.pageY; return Math.hypot(dx,dy); }
  function centroid(a: NativeTouchEvent, b: NativeTouchEvent){ return { cx:(a.pageX+b.pageX)/2, cy:(a.pageY+b.pageY)/2 }; }

  const pinchRef = useRef({
    pinching:false, startZoom:1, startDist:1,
    startTx:0, startTy:0, startCx:0, startCy:0,
  });

  const onTouchStart = (e: GestureResponderEvent) => {
    const ts = e.nativeEvent.touches;
    if (ts.length === 2) {
      pinchRef.current.pinching = true;
      pinchRef.current.startZoom = pending.current.zoom;
      pinchRef.current.startDist = dist2(ts[0], ts[1]);
      const { cx, cy } = centroid(ts[0], ts[1]);
      pinchRef.current.startCx   = cx;
      pinchRef.current.startCy   = cy;
      pinchRef.current.startTx   = pending.current.tx;
      pinchRef.current.startTy   = pending.current.ty;
    }
  };
  const onTouchMove = (e: GestureResponderEvent) => {
    const ts = e.nativeEvent.touches;
    if (pinchRef.current.pinching && ts.length === 2) {
      const d  = dist2(ts[0], ts[1]) || 1;
      const nz = clampZoom(pinchRef.current.startZoom * (d / (pinchRef.current.startDist || 1)));
      const zx = nz / pinchRef.current.startZoom;
      const { cx, cy } = centroid(ts[0], ts[1]);
      pending.current.zoom = nz;
      pending.current.tx   = cx - (cx - pinchRef.current.startTx) * zx;
      pending.current.ty   = cy - (cy - pinchRef.current.startTy) * zx;
      schedule();
    }
  };
  const onTouchEnd = (e: GestureResponderEvent) => {
    if (e.nativeEvent.touches.length < 2) pinchRef.current.pinching = false;
  };

  // Klikk på etappe
  const onPressLeg = (i:number) => { setActive(i); onLegPress?.(i); };

  // --- NY: FOKUSÉR PÅ currentLeg (ved mount / endring) ---
  const focusedOnce = useRef(false);
  React.useEffect(() => {
    if (vp.width===0 || vp.height===0) return;
    const idx = (typeof currentLeg === "number" && currentLeg >= 0 && currentLeg < simplifiedLegs.length)
      ? currentLeg
      : (initialActive >= 0 ? initialActive : -1);

    if (idx < 0) {
      // åpne med full rute (zoom=1, center allerede via mx/my)
      pending.current = { zoom: 1, tx: 0, ty: 0 };
      schedule();
      return;
    }
    // beregn bbox for aktuell etappe i piksel-rom
    const pts = simplifiedLegs[idx];
    if (!pts || pts.length === 0) return;

    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for (const [x,y] of pts) {
      if (x<minX) minX=x; if (x>maxX) maxX=x;
      if (y<minY) minY=y; if (y>maxY) maxY=y;
    }
    const pad = Math.max(0, Math.min(0.4, focusPad)); // 0..0.4
    const dx = Math.max(1, maxX - minX);
    const dy = Math.max(1, maxY - minY);
    const scale = Math.min(
      vp.width  / (dx * (1 + pad*2)),
      vp.height / (dy * (1 + pad*2)),
    );
    const zoom = clampZoom(scale); // vi ligger i piksel-rom allerede, så scale=zoom
    // senter
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    // finn tx/ty slik at (cx,cy) havner i midten av viewport
    const tx = vp.width/2  - cx * zoom;
    const ty = vp.height/2 - cy * zoom;

    pending.current = { zoom, tx, ty };
    schedule();
    focusedOnce.current = true;
    setActive(idx);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [vp.width, vp.height, currentLeg, initialActive, simplifiedLegs, focusPad]);

  return (
    <View style={styles.root} onLayout={onLayout}>
      {vp.width>0 && vp.height>0 ? (
        <>
          <Svg width="100%" height="100%">
            <G ref={gRef as any}>
              {/* Rød, felles synlig path (svært rask) */}
              <Path
                d={visiblePath}
                fill="none"
                stroke="#c33"
                strokeWidth={3}
                vectorEffect="non-scaling-stroke"
                strokeLinecap="round"
                strokeLinejoin="round"
              />
              {/* Blå highlight */}
              {activePath ? (
                <Path
                  d={activePath}
                  fill="none"
                  stroke="#06f"
                  strokeWidth={4}
                  vectorEffect="non-scaling-stroke"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                />
              ) : null}

              {/* Markører på start/slutt for alle etapper */}
              {legEndpoints.map((e, i) => (
                <React.Fragment key={`mk-${i}`}>
                  {e.start ? <Circle cx={e.start[0]} cy={e.start[1]} r={5} fill="#2E7D32" stroke="#fff" strokeWidth={1.5} /> : null}
                  {e.end   ? <Circle cx={e.end[0]}   cy={e.end[1]}   r={5} fill="#C62828" stroke="#fff" strokeWidth={1.5} /> : null}
                </React.Fragment>
              ))}

              {/* Usynlige “hit”-paths for trykk */}
              {hitPaths.map((d, i) => d ? (
                <Path
                  key={`hit-${i}`}
                  d={d}
                  fill="none"
                  stroke="transparent"
                  strokeWidth={18}
                  vectorEffect="non-scaling-stroke"
                  onPress={() => onLegPress?.(i)}
                />
              ) : null)}
            </G>
          </Svg>

          {/* Gest-område inni kartet */}
          <View
            style={StyleSheet.absoluteFill}
            pointerEvents="auto"
            {...panResponder.panHandlers}
            onTouchStart={(e)=>{ onTouchStart(e); }}
            onTouchMove={(e)=>{ onTouchMove(e); }}
            onTouchEnd={(e)=>{ onTouchEnd(e); }}
            onTouchCancel={(e)=>{ onTouchEnd(e); }}
          />
        </>
      ) : null}

      <View style={styles.hud} pointerEvents="none">
        <Text style={styles.hudText}>
          etapper: {legs.length} • aktiv: {active>=0?active+1:"-"} • {vp.width}×{vp.height}
        </Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  root: { flex: 1, backgroundColor: "#f5f5f5" },
  hud: {
    position: "absolute",
    left: 8, bottom: 8,
    backgroundColor: "rgba(0,0,0,0.6)",
    paddingHorizontal: 8, paddingVertical: 6,
    borderRadius: 8,
  },
  hudText: { color: "#fff", fontWeight: "600" },
});
